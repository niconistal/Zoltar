package org.isistan.flabot.spectrum.behavioral;


import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Vector;

import java.util.HashMap ;

import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.handlers.HandlerUtil;
import org.isistan.flabot.coremodel.Condition;
import org.isistan.flabot.coremodel.Path;
import org.isistan.flabot.coremodel.PathNode;
import org.isistan.flabot.coremodel.ResponsibilityNode;
import org.isistan.flabot.coremodel.StubNode;
import org.isistan.flabot.coremodel.UseCaseMap;
import org.isistan.flabot.edit.editormodel.Diagram;
import org.isistan.flabot.edit.editormodel.FlabotFileModel;
import org.isistan.flabot.edit.multipage.FlabotMultiPageEditor;
import org.isistan.flabot.edit.ucmmodel.UCMDiagram;

import utils2.ExecutionNode;
import utils2.MethodNode;
import utils2.ThreadNode;

public class ZoltarStrategy implements SpectrumStrategy {

	
	private IWorkbenchWindow window;
	FlabotFileModel currentModel = null ;
	
	
	
	private double getOchiaiCoefficient( int resp, ArrayList< ArrayList<Boolean> > spectrum, ArrayList<Boolean> errors ) {
		Double n11 = 0.0,
			n10 = 0.0,
			n01 = 0.0,
			n00 = 0.0 ;
		
		for( int j=0 ; j < spectrum.size() ; j++ ) {
			
			if( (spectrum.get(j).size() <= resp || (! ( spectrum.get(j)).get(resp) ) ) ) {
				if ( !errors.get(j) )
					n00++ ;
				else
					n01++ ;
			} else {
				if ( !errors.get(j) )
					n10++ ;
				else
					n11++ ;
					
			}
			
		}
		System.out.println("resp: "+ resp + n00 +" " + n01 + " " + n11 + " " + n10);
		double ochi = n11 / Math.sqrt((n11+n01)*(n11+n10));
		return  ochi ;

		
	}
	
	
	

	private HashMap<String, Double> processSpectrum( ArrayList<ExecutionNode> trace, ArrayList<Boolean> errorsList ) {
		
		int resp  = 0,
			paths = 0 ;
		
		ArrayList< ArrayList<Boolean> > spectrum = new ArrayList< ArrayList<Boolean> >() ; 
		ArrayList<Boolean> errors = new ArrayList<Boolean>() ;
		HashMap<String, Integer> responsabilities = new HashMap<String, Integer> () ;
		HashMap<String, Double> result = new HashMap<String, Double>() ;
		
		for ( int j=0; j < trace.size() ; j++ ) {
			ArrayList<Boolean> spectrumRow = new ArrayList<Boolean>()  ;
			//Obtengo la traza j
			ExecutionNode path = trace.get(j);
			//Obtengo el thred que quiero
			ThreadNode thread = path.getThread("GameLoop");
			//Obtengo el spectrum
			MethodNode threadSpectrum = thread.getSpectrum();
			//Recorrer el spectrum en preorder e ir armando el spectrum
			LinkedList<MethodNode> fila = new LinkedList<MethodNode>();
			fila.add(thread.getSpectrum());
			while (fila.size() > 0){
				MethodNode currentMethod = fila.pollFirst();
				String id = currentMethod.getName();
				if (! responsabilities.containsKey(threadSpectrum.getName())){
					responsabilities.put(threadSpectrum.getName(),resp++);
				}
				while(responsabilities.get(id) >= spectrumRow.size())
					spectrumRow.add(false) ;
				spectrumRow.set( responsabilities.get(id), true ) ;
				
				for ( MethodNode m : currentMethod.getChildren()){
					fila.addLast(m);
				}
			}
			spectrum.add(spectrumRow) ;	
			//fijarme si tiene error o no esa traza.
			errors.add(errorsList.get(j));
			for( int i = 0 ; i < resp ; i++ ) {
				double ochi = getOchiaiCoefficient(i, spectrum, errors) ;
				for( String key : responsabilities.keySet()) {
					if ( responsabilities.get(key).equals(i) ) {
						result.put(key, ochi) ;
						break ;
					}
				}
			}
		}
		return result;
	}



}